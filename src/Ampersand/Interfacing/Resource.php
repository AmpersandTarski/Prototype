<?php

/*
 * This file is part of the Ampersand backend framework.
 *
 */

namespace Ampersand\Interfacing;

use stdClass;
use ArrayAccess;
use Exception;
use Ampersand\Core\Atom;
use Ampersand\Core\Concept;
use Ampersand\Log\Logger;
use Ampersand\Interfacing\Options;
use Ampersand\Interfacing\InterfaceObjectInterface;
use Ampersand\Interfacing\ResourcePath;
use function Ampersand\Misc\getSafeFileName;

/**
 *
 * @author Michiel Stornebrink (https://github.com/Michiel-s)
 *
 */
class Resource extends Atom implements ArrayAccess
{
    /**
     * Interface for this resource.
     * The interface defines which properties and methods the resource has.
     * Interface definitions are generated by the Ampersand prototype generator.
     *
     * @var \Ampersand\Interfacing\InterfaceObjectInterface
     */
    protected $ifc;

    /**
     * Parent resource
     *
     * @var \Ampersand\Interfacing\Resource|null
     */
    protected $parent = null;
    
    /**
     * Constructor
     *
     * @param string $resourceId Ampersand atom identifier
     * @param \Ampersand\Core\Concept $cpt
     * @param \Ampersand\Interfacing\InterfaceObjectInterface $ifc
     * @param \Ampersand\Interfacing\Resource|null $parent
     */
    public function __construct(string $resourceId, Concept $cpt, InterfaceObjectInterface $ifc, Resource $parent = null)
    {
        if (!$cpt->isObject()) {
            throw new Exception("Cannot instantiate resource, because its type '{$cpt}' is a non-object concept", 400);
        }
        
        // Call Atom constructor
        parent::__construct($resourceId, $cpt);

        $this->ifc = $ifc;
        $this->parent = $parent;
    }

    /**
     * Function is called when object is treated as a string
     * This functionality is needed when the ArrayAccess::offsetGet method below is used by internal code
     *
     * @return string
     */
    public function __toString()
    {
        return (string) parent::jsonSerialize();
    }

    /**
     * Return interface for this resource
     *
     * @return \Ampersand\Interfacing\InterfaceObjectInterface
     */
    public function getIfc(): InterfaceObjectInterface
    {
        return $this->ifc;
    }
    
    /**
     * Return path to this resource
     *
     * @return string
     */
    public function getPath(): string
    {
        return $this->ifc->buildResourcePath($this, $this->parent);
    }

    public function one(string $ifcId, string $tgtId): Resource
    {
        return $this->ifc->getSubinterface($ifcId, Options::INCLUDE_REF_IFCS | Options::INCLUDE_LINKTO_IFCS)->one($this, $tgtId);
    }

/**************************************************************************************************
 * ArrayAccess methods
 *************************************************************************************************/

    public function offsetExists($offset)
    {
        return $this->ifc->hasSubinterface($offset, Options::INCLUDE_REF_IFCS | Options::INCLUDE_LINKTO_IFCS);
    }

    public function offsetGet($offset)
    {
        $ifcObj = $this->ifc->getSubinterface($offset, Options::INCLUDE_REF_IFCS | Options::INCLUDE_LINKTO_IFCS);
        $tgts = $ifcObj->all($this);

        if ($ifcObj->isUni()) {
            return empty($tgts) ? null : current($tgts);
        } else {
            return $tgts;
        }
    }

    public function offsetSet($offset, $value)
    {
        throw new Exception("Resource::offsetSet not yet implemented", 501);
        // $ifcObj = $this->ifc->getSubinterface($offset, Options::INCLUDE_REF_IFCS | Options::INCLUDE_LINKTO_IFCS);
        // $ifcObj->set($this, $value);
    }

    public function offsetUnset($offset)
    {
        throw new Exception("Resource::offsetSet not yet implemented", 501);
        // $ifcObj = $this->ifc->getSubinterface($offset, Options::INCLUDE_REF_IFCS | Options::INCLUDE_LINKTO_IFCS);
        // $ifcObj->set($this, null);
    }

/**************************************************************************************************
 * REST methods to call on Resource
 *************************************************************************************************/
 
    /**
     * Get resource data according to provided interface
     * @param int $options
     * @param int|null $depth
     * @return array|string
     */
    public function get(int $options = Options::DEFAULT_OPTIONS, int $depth = null)
    {
        return $this->ifc->read($this, $options, $depth);
    }
    
    /**
     * Update a resource (updates only first level of subinterfaces, for now)
     * @param \stdClass|null $resourceToPut
     * @return \Ampersand\Interfacing\Resource $this
     */
    public function put(stdClass $resourceToPut = null): Resource
    {
        if (!isset($resourceToPut)) {
            return $this; // nothing to do
        }

        // Perform PUT using the interface definition
        foreach ($resourceToPut as $ifcId => $value) {
            if (substr($ifcId, 0, 1) === '_' && substr($ifcId, -1) === '_') {
                continue; // skip special internal attributes
            }
            try {
                $subifc = $this->ifc->getSubinterface($ifcId, Options::INCLUDE_REF_IFCS | Options::INCLUDE_LINKTO_IFCS);
            } catch (Exception $e) {
                Logger::getLogger('INTERFACING')->warning("Unknown attribute '{$ifcId}' in PUT data");
                continue;
            }

            if ($subifc->isUni()) { // expect value to be object or literal
                if (isset($value->_id_)) { // object with _id_ attribute
                    $subifc->set($this, $value->_id_);
                } else { // null object, string (object id) or literal
                    $subifc->set($this, $value);
                }
            } else { // expect value to be array
                if (!is_array($value)) {
                    throw new Exception("Array expected but not provided while updating " . $subifc->getPath(), 400);
                }
                
                // First empty existing list
                $subifc->removeAll($this);
                
                // Add provided values
                foreach ($value as $item) {
                    if (isset($item->_id_)) { // object with _id_ attribute
                        $subifc->add($this, $item->_id_);
                    } else { // null object, string (object id) or literal
                        $subifc->add($this, $item);
                    }
                }
            }
        }
        
        // Clear query data
        $this->setQueryData(null);
        
        return $this;
    }
    
    /**
     * Patch this resource with provided patches
     * Use JSONPatch specification for $patches (see: http://jsonpatch.com/)
     *
     * @param array $patches
     * @return \Ampersand\Interfacing\Resource $this
     */
    public function patch(array $patches): Resource
    {
        foreach ($patches as $key => $patch) {
            if (!property_exists($patch, 'op')) {
                throw new Exception("No 'op' (i.e. operation) specfied for patch #{$key}", 400);
            }
            if (!property_exists($patch, 'path')) {
                throw new Exception("No 'path' specfied for patch #{$key}", 400);
            }

            $resourcePath = new ResourcePath($this, $patch->path);
            $resource = $resourcePath->getTgt();
            $ifc = $resourcePath->getTrailingIfc();
            
            // Process patch
            switch ($patch->op) {
                case "replace":
                    if (!property_exists($patch, 'value')) {
                        throw new Exception("Cannot patch replace. No 'value' specfied for patch #{$key}", 400);
                    }
                    if (is_null($ifc)) {
                        throw new Exception("Cannot patch replace. Path for patch #{$key} MUST end with a resource property", 400);
                    }
                    $ifc->set($resource, $patch->value);
                    break;
                case "add":
                    if (!property_exists($patch, 'value')) {
                        throw new Exception("Cannot patch add. No 'value' specfied for patch #{$key}", 400);
                    }
                    if (is_null($ifc)) {
                        throw new Exception("Cannot patch add. Path for patch #{$key} MUST end with a resource property", 400);
                    }
                    $ifc->add($resource, $patch->value);
                    break;
                case "remove":
                    // Regular json patch remove operation, uses last part of 'path' attribuut as resource to remove from list
                    if (!property_exists($patch, 'value')) {
                        if (!is_null($ifc)) {
                            throw new Exception("Cannot patch remove. Path for patch #{$key} MUST end with a resource ór contain a patch value", 400);
                        }
                        $resource->ifc->remove($resource->parent, $resource);
                    // Not part of official json path specification. Uses 'value' attribute that must be removed from list
                    } elseif (property_exists($patch, 'value')) {
                        if (is_null($ifc)) {
                            throw new Exception("Cannot patch remove. Path for patch #{$key} MUST end with a resource property ór NOT contain a patch value", 400);
                        }
                        $ifc->remove($resource, $patch->value);
                    }
                    break;
                default:
                    throw new Exception("Unknown patch operation '{$patch->op}'. Supported are: 'replace', 'add' and 'remove'", 501);
            }
        }
        
        // Clear query data
        $this->setQueryData(null);
        
        return $this;
    }

    public function post($subIfcId, stdClass $resourceToPost = null): Resource
    {
        /** @var \Ampersand\AmpersandApp $ampersandApp */
        global $ampersandApp;
        
        $newResource = $this->ifc->getSubinterface($subIfcId)->create($this);

        // Special case for file upload
        if ($newResource->concept->isFileObject()) {
            if (is_uploaded_file($_FILES['file']['tmp_name'])) {
                $tmp_name = $_FILES['file']['tmp_name'];
                $originalFileName = $_FILES['file']['name'];

                $appAbsolutePath = $ampersandApp->getSettings()->get('global.absolutePath');
                $uploadFolder = $ampersandApp->getSettings()->get('global.uploadPath');
                $dest = getSafeFileName($appAbsolutePath . DIRECTORY_SEPARATOR . $uploadFolder . DIRECTORY_SEPARATOR . $originalFileName);
                $relativePath = $uploadFolder . '/' . pathinfo($dest, PATHINFO_BASENAME); // use forward slash as this is used on the web
                
                $result = move_uploaded_file($tmp_name, $dest);
                
                if (!$result) {
                    throw new Exception("Error in file upload", 500);
                }
                
                // Populate filePath and originalFileName relations in database
                $newResource->link($relativePath, 'filePath[FileObject*FilePath]')->add();
                $newResource->link($originalFileName, 'originalFileName[FileObject*FileName]')->add();
            } else {
                throw new Exception("No file uploaded", 400);
            }
            return $newResource;
        // Regular case
        } else {
            // Put resource attributes
            return $newResource->put($resourceToPost);
        }
    }
    
    /**
     * Delete this resource and remove as target atom from current interface
     * @return \Ampersand\Interfacing\Resource $this
     */
    public function delete(): Resource
    {
        // Perform DELETE using the interface definition
        $this->ifc->delete($this);
        
        return $this;
    }
}
