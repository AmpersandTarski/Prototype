<?php

/*
 * This file is part of the Ampersand backend framework.
 *
 */

namespace Ampersand\Interfacing;

use stdClass;
use ArrayAccess;
use Exception;
use Ampersand\Core\Atom;
use Ampersand\Core\Concept;
use Ampersand\Log\Logger;
use function Ampersand\Misc\isSequential;
use Ampersand\Misc\Config;
use Ampersand\Interfacing\Options;
use Ampersand\Interfacing\InterfaceTxtObject;
use Ampersand\Interfacing\InterfaceObjectFactory;
use Ampersand\Interfacing\InterfaceObjectInterface;
use Ampersand\Interfacing\ResourcePath;

/**
 *
 * @author Michiel Stornebrink (https://github.com/Michiel-s)
 *
 */
class Resource extends Atom implements ArrayAccess
{
    /**
     * Interface for this resource.
     * The interface defines which properties and methods the resource has.
     * Interface definitions are generated by the Ampersand prototype generator.
     *
     * @var \Ampersand\Interfacing\InterfaceObjectInterface
     */
    protected $ifc;

    /**
     * The parent resource (or null when $this resource is entry resource)
     * @var \Ampersand\Interfacing\Resource
     */
    protected $parent = null;
    
    /**
     * Label of resource to be displayed in user interfaces
     * @var string
     */
    protected $label = null;
    
    /**
     * Contains view data of this resource for the UI templates
     * DO NOT initialize var here, isset() is used below
     * @var array $viewData
     */
    protected $viewData;
    
    /**
     * Contains the interface data filled by the get() method
     * @var array|null $ifcData
     */
    protected $ifcData = null;

    /**
     * The path of this resource (including interface and path to parent resource)
     *
     * @var string
     */
    protected $path;

    /**
     * Specifies if user interface data must be included when outputting (json_serialize) the Resource
     * This includes: _id_, _label_ and _view_
     *
     * @var boolean
     */
    protected $inclUserInterfaceData = false;
    
    /**
     * Constructor
     *
     * @param string $resourceId Ampersand atom identifier
     * @param \Ampersand\Core\Concept $cpt
     * @param \Ampersand\Interfacing\InterfaceObjectInterface $ifc
     * @param \Ampersand\Interfacing\Resource $parent
     */
    public function __construct(string $resourceId, Concept $cpt, InterfaceObjectInterface $ifc, Resource $parent = null)
    {
        if (!$cpt->isObject()) {
            throw new Exception("Cannot instantiate resource, because its type '{$cpt}' is a non-object concept", 400);
        }
        
        // Call Atom constructor
        parent::__construct(rawurldecode($resourceId), $cpt); // url decode resource identifier

        $this->ifc = $ifc;
        $this->parent = $parent;
        $this->setPath();
    }

    /**
     * Function is called when object is treated as a string
     * This functionality is needed when the ArrayAccess::offsetGet method below is used by internal code
     *
     * @return string
     */
    public function __toString()
    {
        return (string) parent::jsonSerialize();
    }
    
    /**
     * Returns label (from view or atom id) for this atom
     * @return string
     */
    public function getLabel(): string
    {
        if (!isset($this->label)) {
            $viewStr = implode($this->getView());
            $this->label = empty(trim($viewStr)) ? $this->id : $viewStr; // empty view => label = id
        }
        return $this->label;
    }
    
    /**
     * Function is called when object encoded to json with json_encode()
     *
     * @return array|string
     */
    public function jsonSerialize()
    {
        $content = [];
        if ($this->inclUserInterfaceData) {
            // Add Ampersand atom attributes
            $content['_id_'] = $this->id;
            $content['_label_'] = $this->getLabel();
            $content['_path_'] = $this->getPath();
        
            // Add view data if array is assoc (i.e. not sequential)
            $data = $this->getView();
            if (!isSequential($data)) {
                $content['_view_'] = $data;
            }
        // Not inclUserInterfaceData and ifcData is null -> directly return $this->id
        } elseif (is_null($this->ifcData)) {
            return $this->id;
        }
        
        // Merge with inerface data (which is set when get() method is called before)
        return array_merge($content, (array)$this->ifcData); // cast to array: null => empty array
    }
    
    /**
     * Returns view array of key-value pairs for this atom
     * @return array
     */
    private function getView()
    {
        // If view is not already set
        if (!isset($this->viewData)) {
            $this->viewData = $this->ifc->getViewData($this);
        }
        return $this->viewData;
    }

    /**
     * Undocumented function
     *
     * @return string
     */
    protected function setPath(): string
    {
        if (is_null($this->parent)) {
            if ($this->concept->isSession()) {
                $this->path = "session"; // Don't put session id here, this is implicit
            } else {
                $this->path = "resource/{$this->concept->name}/" . $this->id;
            }
        } else {
            /* Skip resource id for ident interface expressions (I[Concept])
            * I expressions are commonly used for adding structure to an interface using (sub) boxes
            * This results in verbose paths
            * e.g.: pathToApi/resource/Person/John/Person/John/Person details/John/Name
            * By skipping ident expressions the paths are more concise without loosing information
            * e.g.: pathToApi/resource/Person/John/Person/PersonDetails/Name
            */
            if ($this->ifc->isIdent()) {
                $this->path = $parent->getPath();
            } else {
                $this->path = $parent->getPath() . '/' . $this->ifc->getIfcId() . '/' . $this->id;
            }
        }
        return $this->path;
    }

    /**
     * Return interface for this resource
     *
     * @return \Ampersand\Interfacing\InterfaceObjectInterface
     */
    public function getIfc(): InterfaceObjectInterface
    {
        return $this->ifc;
    }
    
    /**
     * @return string
     */
    public function getPath()
    {
        return $this->path;
    }

    public function getProperty(string $ifcId)
    {
        return $this->ifc->getProperty($this, $ifcId);
    }

/**************************************************************************************************
 * ArrayAccess methods
 *************************************************************************************************/
    public function offsetExists($offset)
    {
        // Get data (1 level deep) if icfData is not (yet) set
        if (is_null($this->ifcData)) {
            $this->get(Options::INCLUDE_REF_IFCS | Options::INCLUDE_LINKTO_IFCS, 1);
        }
        return isset($this->ifcData[$offset]);
    }

    public function offsetGet($offset)
    {
        // Get data (1 level deep) if icfData is not (yet) set
        if (is_null($this->ifcData)) {
            $this->get(Options::INCLUDE_REF_IFCS | Options::INCLUDE_LINKTO_IFCS, 1);
        }

        if ($this->ifc->getSubinterface($offset)->isUni()) {
            // Value can be Atom/Resource or scalar
            return $this->ifcData[$offset]->id ?? $this->ifcData[$offset] ?? null;
        } else {
            return array_map(function (Resource $resource) {
                return $resource->id ?? $resource; // value can be Atom/Resource or scalar
            }, $this->ifcData[$offset]);
        }
    }

    public function offsetSet($offset, $value)
    {
        throw new Exception("ArrayAccess::offsetSet() not implemented on Resource class", 500);
    }

    public function offsetUnset($offset)
    {
        throw new Exception("ArrayAccess::offsetUnset() not implemented on Resource class", 500);
    }

/**************************************************************************************************
 * REST methods to call on Resource
 *************************************************************************************************/
 
    /**
     * Get resource data according to provided interface
     * @param int $options
     * @param int|null $depth
     * @param array $recursionArr
     * @return mixed
     */
    public function get(int $options = Options::DEFAULT_OPTIONS, int $depth = null, array $recursionArr = [])
    {
        return $this->ifc->get($this, $options, $depth, $recursionArr);
    }
    
    /**
     * Update a resource (updates only first level of subinterfaces, for now)
     * @param \stdClass|null $resourceToPut
     * @return \Ampersand\Interfacing\Resource $this
     */
    public function put(stdClass $resourceToPut = null): Resource
    {
        if (!isset($resourceToPut)) {
            return $this; // nothing to do
        }

        // Perform PUT using the interface definition
        foreach ($resourceToPut as $ifcId => $value) {
            if (substr($ifcId, 0, 1) == '_' && substr($ifcId, -1) == '_') {
                continue; // skip special internal attributes
            }
            try {
                $subifc = $this->ifc->getSubinterface($ifcId);
            } catch (Exception $e) {
                Logger::getLogger('INTERFACING')->warning("Unknown attribute '{$ifcId}' in PUT data");
                continue;
            }
            $subifc->put($this, $value);
        }
        
        // Clear query data
        $this->setQueryData(null);
        
        return $this;
    }
    
    /**
     * Patch this resource with provided patches
     * Use JSONPatch specification for $patches (see: http://jsonpatch.com/)
     *
     * @param array $patches
     * @return \Ampersand\Interfacing\Resource $this
     */
    public function patch(array $patches): Resource
    {
        foreach ($patches as $key => $patch) {
            if (!property_exists($patch, 'op')) {
                throw new Exception("No 'op' (i.e. operation) specfied for patch #{$key}", 400);
            }
            if (!property_exists($patch, 'path')) {
                throw new Exception("No 'path' specfied for patch #{$key}", 400);
            }

            $resourcePath = new ResourcePath($this, $patch->path);
            $resource = $resourcePath->getTgt();
            $ifc = $resourcePath->getTrailingIfc();
            
            // Process patch
            switch ($patch->op) {
                case "replace":
                    if (!property_exists($patch, 'value')) {
                        throw new Exception("Cannot patch replace. No 'value' specfied for patch #{$key}", 400);
                    }
                    if (is_null($ifc)) {
                        throw new Exception("Cannot patch replace. Path for patch #{$key} MUST end with a resource property", 400);
                    }
                    $ifc->set($resource, $patch->value);
                    break;
                case "add":
                    if (!property_exists($patch, 'value')) {
                        throw new Exception("Cannot patch add. No 'value' specfied for patch #{$key}", 400);
                    }
                    if (is_null($ifc)) {
                        throw new Exception("Cannot patch add. Path for patch #{$key} MUST end with a resource property", 400);
                    }
                    $ifc->add($resource, $patch->value);
                    break;
                case "remove":
                    // Regular json patch remove operation, uses last part of 'path' attribuut as resource to remove from list
                    if (!property_exists($patch, 'value')) {
                        if (!is_null($ifc)) {
                            throw new Exception("Cannot patch remove. Path for patch #{$key} MUST end with a resource ór contain a patch value", 400);
                        }
                        $resource->ifc->remove($resource->parent, $resource);
                    // Not part of official json path specification. Uses 'value' attribute that must be removed from list
                    } elseif (property_exists($patch, 'value')) {
                        if (is_null($ifc)) {
                            throw new Exception("Cannot patch remove. Path for patch #{$key} MUST end with a resource property ór NOT contain a patch value", 400);
                        }
                        $ifc->remove($resource, $patch->value);
                    }
                    break;
                default:
                    throw new Exception("Unknown patch operation '{$patch->op}'. Supported are: 'replace', 'add' and 'remove'", 501);
            }
        }
        
        // Clear query data
        $this->setQueryData(null);
        
        return $this;
    }

    public function post($subIfcId, $resourceToPost): Resource
    {
        return $this->ifc->getSubinterface($subIfcId)->create($this, $resourceToPost);
    }
    
    /**
     * Delete this resource and remove as target atom from current interface
     * @return \Ampersand\Interfacing\Resource $this
     */
    public function delete(): Resource
    {
        // Perform DELETE using the interface definition
        $this->ifc->delete($this);
        
        return $this;
    }
}
